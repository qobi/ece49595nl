(define (on x y)
 (cond ((and (eq? (first x) 'square) (eq? (first y) 'rank))
	(= (second x) (second y)))
       ((and (eq? (first x) 'square) (eq? (first y) 'file))
	(= (third x) (second y)))
       ((and (or (eq? (first x) 'white) (eq? (first x) 'black))
	     (eq? (first y) 'square))
	(and (= (third x) (second y)) (= (fourth x) (third y))))
       ((and (or (eq? (first x) 'white) (eq? (first x) 'black))
	     (eq? (first y) 'rank))
	(= (third x) (second y)))
       ((and (or (eq? (first x) 'white) (eq? (first x) 'black))
	     (eq? (first y) 'file))
	(= (fourth x) (second y)))
       ;; this fail implements a semantic constraint
       (else (fail))))

(define (of x y)
 (cond ((and (eq? (first x) 'square) (eq? (first y) 'rank))
	(= (second x) (second y)))
       ((and (eq? (first x) 'square) (eq? (first y) 'file))
	(= (third x) (second y)))
       ((and (eq? (first x) 'square)
	     (or (eq? (first y) 'white) (eq? (first y) 'black)))
	(and (= (second x) (third y)) (= (third x) (fourth y))))
       ((and (eq? (first x) 'rank) (eq? (first y) 'square))
	(= (second x) (second y)))
       ((and (eq? (first x) 'rank)
	     (or (eq? (first y) 'white) (eq? (first y) 'black)))
	(= (second x) (third y)))
       ((and (eq? (first x) 'file) (eq? (first y) 'square))
	(= (second x) (third y)))
       ((and (eq? (first x) 'file)
	     (or (eq? (first y) 'white) (eq? (first y) 'black)))
	(= (second x) (fourth y)))
       ;; this fail implements a semantic constraint
       (else (fail))))

(define (initialize-lexicon)
 (let ((objects
	`(,@(reduce append
		    (map-n (lambda (rank)
			    (map-n (lambda (file) `(square ,rank ,file)) 8))
			   8)
		    '())
	  ,@(map-n (lambda (rank) `(rank ,rank)) 8)
	  ,@(map-n (lambda (file) `(file ,file)) 8)
	  ,@(map (lambda (chessboard-square)
		  (list (first (chessboard-square-contents chessboard-square))
			(second (chessboard-square-contents chessboard-square))
			(chessboard-square-i chessboard-square)
			(chessboard-square-j chessboard-square)))
		 (remove-if-not chessboard-square-contents
				(vector->list *chessboard*))))))
  (set! *lexicon*
	`(("square" (object -> boolean) ,(lambda (x) (eq? (first x) 'square)))
	  ("piece" (object -> boolean)
		   ,(lambda (x)
		     (or (eq? (second x) 'pawn)
			 (eq? (second x) 'bishop)
			 (eq? (second x) 'knight)
			 (eq? (second x) 'rook)
			 (eq? (second x) 'queen)
			 (eq? (second x) 'king))))
	  ("pawn" (object -> boolean) ,(lambda (x) (eq? (second x) 'pawn)))
	  ("bishop" (object -> boolean) ,(lambda (x) (eq? (second x) 'bishop)))
	  ("knight" (object -> boolean) ,(lambda (x) (eq? (second x) 'knight)))
	  ("rook" (object -> boolean) ,(lambda (x) (eq? (second x) 'rook)))
	  ("queen" (object -> boolean) ,(lambda (x) (eq? (second x) 'queen)))
	  ("king" (object -> boolean) ,(lambda (x) (eq? (second x) 'king)))
	  ("rank" (object -> boolean) ,(lambda (x) (eq? (first x) 'rank)))
	  ("file" (object -> boolean) ,(lambda (x) (eq? (first x) 'file)))
	  ("edge" (object -> boolean)
		  ,(lambda (x)
		    (and (or (eq? (first x) 'rank) (eq? (first x) 'file))
			 (or (= (second x) 0) (= (second x) 7)))))
	  ("corner" (object -> boolean)
		    ,(lambda (x)
		      (and (eq? (first x) 'square)
			   (or (= (second x) 0) (= (second x) 7))
			   (or (= (third x) 0) (= (third x) 7)))))
	  ("black" ((object -> boolean) -> (object -> boolean))
		   ,(lambda (noun)
		     (lambda (x)
		      (and (noun x)
			   (cond
			    ((eq? (first x) 'black) #t)
			    ((eq? (first x) 'white) #f)
			    ((eq? (first x) 'square)
			     (odd? (+ (second x) (third x))))
			    ;; this fail implements a semantic constraint
			    (else (fail)))))))
	  ("white" ((object -> boolean) -> (object -> boolean))
		   ,(lambda (noun)
		     (lambda (x)
		      (and (noun x)
			   (cond
			    ((eq? (first x) 'black) #f)
			    ((eq? (first x) 'white) #t)
			    ((eq? (first x) 'square)
			     (even? (+ (second x) (third x))))
			    ;; this fail implements a semantic constraint
			    (else (fail)))))))
	  ("every" ((object -> boolean) -> ((object -> boolean) -> boolean))
		   ,(lambda (noun)
		     (lambda (vp)
		      (every
		       (lambda (x) (or (not (noun x)) (vp x))) objects))))
	  ("some" ((object -> boolean) -> ((object -> boolean) -> boolean))
		  ,(lambda (noun)
		    (lambda (vp)
		     (some (lambda (x) (and (noun x) (vp x))) objects))))
	  ("the" ((object -> boolean) -> ((object -> boolean) -> boolean))
		 ,(lambda (noun)
		   (lambda (vp)
		    (if (= (count-if noun objects) 1)
			(vp (find-if noun objects))
			(fail)))))

	  ("of" (((object -> boolean) -> boolean)
		 ->
		 ((object -> boolean) <- (object -> boolean)))
		,(lambda (np)
		  (lambda (noun)
		   (lambda (x)
		    (and (noun x) (np (lambda (y) (of x y))))))))
	  ("on" (((object -> boolean) -> boolean)
		 ->
		 ((object -> boolean) <- (object -> boolean)))
		,(lambda (np)
		  (lambda (noun)
		   (lambda (x)
		    (and (noun x) (np (lambda (y) (on x y))))))))
	  ("is"
	   (((object -> boolean) <- (object -> boolean))
	    ->
	    (boolean <- ((object -> boolean) -> boolean)))
	   ,(lambda (pp) (lambda (subject) (subject (pp (lambda (x) #t))))))
	  ("is"
	   (((object -> boolean) <- (object -> boolean))
	    ->
	    (boolean <- ((object -> boolean) -> boolean)))
	   ,(lambda (pp)
	     (lambda (subject)
	      (subject
	       (pp (lambda (y) (subject (lambda (x) (equal? x y)))))))))
	  ("is" (((object -> boolean) -> boolean)
		 ->
		 (boolean <- ((object -> boolean) -> boolean)))
		,(lambda (object)
		  (lambda (subject)
		   (subject (lambda (x) (object (lambda (y) (equal? x y))))))))
	  ("is"
	   (((object -> boolean) -> boolean)
	    ->
	    (boolean <- ((object -> boolean) -> boolean)))
	   ,(lambda (object)
	     (lambda (subject)
	      (object (lambda (y) (subject (lambda (x) (equal? x y))))))))))))

(define (lookup-word word lexicon)
 ;; this fail implements, in part, the syntactic constraint
 (cond ((null? lexicon) (fail))
       ((string-ci=? word (first (first lexicon)))
	;; this either introduces lexical ambiguity
	(either (list (second (first lexicon)) (third (first lexicon)))
		(lookup-word word (rest lexicon))))
       (else (lookup-word word (rest lexicon)))))

(define (interpret stack type words lexicon)
 (either
  ;; shift
  (if (null? words)
      (if (and (null? (rest stack)) (equal? (first (first stack)) type))
	  (second (first stack))
	  ;; this fail implements, in part, the syntactic constraint
	  (fail))
      (interpret (cons (lookup-word (first words) lexicon) stack)
		 type (rest words) lexicon))
  ;; reduce forward
  (if (and (not (null? stack))
	   (not (null? (rest stack)))
	   (pair? (first (second stack)))
	   (eq? (second (first (second stack))) '->)
	   (equal? (first (first (second stack))) (first (first stack))))
      (interpret (cons (list (third (first (second stack)))
			     ((second (second stack)) (second (first stack))))
		       (rest (rest stack)))
		 type words lexicon)
      ;; this fail implements, in part, the syntactic constraint
      (fail))
  ;; reduce backward
  (if (and (not (null? stack))
	   (not (null? (rest stack)))
	   (pair? (first (first stack)))
	   (eq? (second (first (first stack))) '<-)
	   (equal? (third (first (first stack))) (first (second stack))))
      (interpret (cons (list (first (first (first stack)))
			     ((second (first stack)) (second (second stack))))
		       (rest (rest stack)))
		 type words lexicon)
      ;; this fail implements, in part, the syntactic constraint
      (fail))))
